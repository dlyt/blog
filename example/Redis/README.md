### 数据类型
- String
- Hash
- List
- Set
- Sorted set
### RDB 持久化
因为 Redis 是内存数据库，它将自己的数据库状态存储在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。

为了解决这个问题，Redis 提供了 RDB 持久化功能，这个功能可以将 Redis 在内存中数据库状态保存到磁盘里面，避免数据意外丢失。

RDB 持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个 RDB 文件中。

RDB 持久化功能所生成的 RDB 文件是一个经过压缩的二进制文件，通过该文件可以还原生成 RDB 文件时的数据库状态。
### AOF 持久化
除了 RDB 持久化功能之外，Redis 还提供了 AOF（Append Only File）持久化功能。与 RDB 持久化通过保存数据库中的键值对来记录数据库状态不同，AOF 持久化是通过保存 Redis 服务器所执行的写命令来记录数据状态。
#### AOF 持久化的实现
AOF 持久化功能的实现可以分为命令追加（append）、文件写入、文件同步（sync）三个步骤。
##### 命令追加
当 AOF 持久化功能处于打开状态时，服务器在执行完一个命令之后，会以协议格式将被执行的写命令追加到服务器状态的 aof_buf 缓冲区的末尾。
##### AOF 文件的写入与同步
Redis 的服务器进程就是一个事件循环（loop），这个循环中的文件事件负责收客户端的命令请求，以及向客户端发送命令回复，而时间事件则负责执行像 serverCron 函数这样需要定时运行的函数。

因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到 aof_buf 缓冲区里面，所以在服务器每次结束一个事件循环之前，它都会调用 flushAppendOnlyFile 函数，考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到　AOF 文件里面。

flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定。
#### 重写
AOF 重写可以产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。
#### Hash应用场景
需求：存储一个用户信息表数据

解决方案：

key/value结构存储

![](https://github.com/dlyt/blog/blob/master/imgs/image2.jpg)

第一种方式将用户ID作为查找key，把其他信息封装成一个对象以序列化的方式存储，这种方式的缺点是，增加了序列化/反序列化的开销，并且在需要修改其中一项信息时，需要把整个对象取回，并且修改操作需要对并发进行保护，引入CAS等复杂问题。
- 序列化： 将数据结构或对象转换成二进制串的过程。
- 反序列化：将在序列化过程中所生成的二进制串转换成数据结构或者对象的过程。
- CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做

![](https://github.com/dlyt/blog/blob/master/imgs/image3.jpg)

第二种方法是这个用户信息对象有多少成员就存成多少个key-value，用用户ID+对应属性的名称作为唯一标识来取得对应属性的值，虽然省去了序列化开销和并发问题，但是用户ID为重复存储。

Hash结构存储

![](https://github.com/dlyt/blog/blob/master/imgs/image4.jpg)

Redis 的 Hash 实际上是内部存储的 Value 为一个 Hash Map ,并提供了直接存取这个 Map 成员的接口。
#### List应用场景
Redis List 的应用场景非常多，也是 Redis 最重要的数据结构之一，比如 twitter 的关注列表，粉丝列表等都可以用 Redis 的 List 结构来实现。
List 就是链表。使用 List 结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用 List 的 push 操作，将任务存在 List 中，然后工作线程再用 pop 操作将任务取出进行执行。
#### Set应用场景
Redis set 对外提供的功能与 List 类似是一个列表的功能，特色之处在于 Set 是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。
Set 集合的概念就是一对不重复值的组合。利用 Redis 提供的 Set 数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户索引的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同洗好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存到一个新的集合中。
#### Sorted Set应用场景
Redis Sorted Set 的使用场景与 Set 类似，区别是 Set 不是自动有序的，而 Sorted Set 可以通过用户额外提供一个优先级的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择 Sorted Set 数据结构，比如 twitter 的 public timeline 可以以发表时间作为 Score 来存储，这样获取时就是自动按照时间排好序的。

另外还可以用 Sorted Set 来做带权重的队列，比如普通消息的 Score 为1，重要消息的 Score 为2，然后工作线程可以选择按　Score 的倒叙来获取工作任务。让重要的任务优先执行。