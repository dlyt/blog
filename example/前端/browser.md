### 解释一下事件冒泡和事件捕获呢？如何阻止冒泡？如何阻止默认事件？

事件冒泡：事件从最深的节点开始，然后逐步向上传播事件的过程；
事件捕获：从`window`开始，逐步向最深的节点传播事件的过程；
阻止冒泡：window.event ? window.event.cancelBubble = true(IE) : e.stopPropagetion()
阻止默认事件：e.preventDefault() || window.event.returnValue = false(IE)

### 浏览器的回流与重绘 (Reflow & Repaint)

回流一定引起重绘，重绘不一定回流

先隐藏，操作完成再显示
一次性加入 document
尽量使用css属性简写

## 回流
当`Render Tree`中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或者全部文档的过程称为回流

会导致回流的操作：
页面首次渲染、浏览器窗口大小发生改变、元素尺寸或位置发生改变、元素内容变化、元素字体变化、添加或删除可见的DOM元素、激活CSS伪类（:hover)、查询某些属性或调用某些方法。
当渲染树中的元素布局（如；尺寸、位置、隐藏/状态）发生改变时，产生回流；
JS 获取 Layout 属性值也会引起回流。

## 重绘
当页面中元素样式的改变并不影响它在文档流中的位置时，浏览器会将新样式赋予给元素并重新绘制它，这个过程为重绘。
当渲染树中的元素外观发生改变，不影响布局时，产生重绘；


### https 实现原理
第一步：客户端发送ssl协议版本号，随机数，加密算法等；
第二步：服务端确认加密算法，返回数字证书，服务端生成的随机数等；
第三步：客户端确认数字证书的有效性，生成一个新的随机数，然后使用数字证书中的公钥加密这个随机数；
第四步：服务端通过私钥获取客户端的随机数；
第五步：客户端和服务端通过约定的加密方法，加密三个随机数生成对话秘钥；

### 为什么一定要用三个随机数
不信任每个主机都能产生完全随机的随机数，三个伪随机十分接近随机。

### http/2.0 相比 1.0 有哪些重大改进
多路复用：允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。
二进制分帧：在应用层（HTTP/2）和传输层（TCP or UDP）之间增加一个二进制分帧层。在层中将传输的信息分割为更小的消息和帧，并采用二进制格式的编码。就是多加了一层，专门将消息分成了更小的二进制编码的帧。减少了传输量。
首部压缩：新的压缩算法，减少首部大小，提升发送效率。
服务推送：客户端请求一个资源，服务端把可用户端可能需要请求的其他资源一起主动发给它，减少交互次数。另外服务端还能缓存这样的资源，提升效率。

### cookie、sessionStorage、localStorage
cookie 始终在同源的http请求中携带，可以限制cookie只属于某个路径下；

cookie 只有4k，其他5M；

sessionStorage 仅在当前浏览器窗口关闭前有效；

localStorage 始终有效

### 从URL输入到页面展现发生了什么
1. DNS解析，将域名转成ip地址
  浏览器如何通过域名查询IP：本地hosts，本地DNS服务器先查缓存，没有就请求DNS根服务器，查到顶级域服务器ip地址，接着查二级，三级，最后记录，应答。
2. TCP三次握手
  syn = 1, seq = x
  syn = 1, seq = y, ack = x + 1
  ack = y + 1, seq = z
  为什么3次：网络延迟，二次握手会有不必要的连接。
3. 发送HTTP请求
  请求报文：请求行、请求头、请求体。
  请求行：请求方法，URL，协议版本
  请求头：Accept: text/html 代表浏览器可以接受服务器回发的类型、Referer、cookie等；
  请求体：请求参数
  响应报文：响应行（协议版本，状态码），响应头部，响应主体。
4. TCP 四次挥手
  fin = 1，ack = z, seq = x
  ack = x + 1,seq = z
  fin = 1, ack = x, seq = y
  ack = y, seq = x